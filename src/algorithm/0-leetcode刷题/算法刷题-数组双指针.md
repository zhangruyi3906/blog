---
title: 算法刷题-数组双指针
date: 2023-10-18
category:
  - Algorithm
  - 数组
tag:
  - Algorithm
  - 数组 
---

# 算法刷题-数组

## [27. 移除元素-双指针](https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

### 思路

双指针：

定义两个指针：慢指针和快指针 ，慢指针指向最终需要返回的结果，快指针指向走在前面的元素

如果快指针位置的值!=val ，那么就给慢指针，同时慢指针+1。

### 代码

```cpp
    int removeElement(vector<int>& nums, int val) {
        int n=nums.size();
        int slow=0,fast=0;
        for(;fast<n;fast++){
            if(nums[fast]!=val){
                nums[slow++]=nums[fast];
            }
        }     
        return slow;
    }
```

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

### 思路

双指针，遍历一次数组，每次把当前元素`nums[i]`放入到结果中，然后指针往后走，直到和当前元素不同，此时再进行赋值`i=j-1`

### 代码

```cpp
    int removeDuplicates(vector<int>& nums) {
        int pos=0;
        for(int i=0;i<nums.size();i++){
            int j=i;
            while(j<nums.size() && nums[j]==nums[i]) j++;
            nums[pos++]=nums[i];
            i=j-1;
        }
        return pos;
    }
```

## [283. 移动零-双指针](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

### 思路

双指针：

可以转换为：将所有非0的数字都放在前面，并且保持顺序不变

快指针走在前面，每次遇到非0的数就给慢指针，直到结束

最后再让慢指针走完，把剩下的都赋值为0即可。

### 代码

```cpp
    void moveZeroes(vector<int>& nums) {
        int n=nums.size();
        int pos=0;
        for(int i=0;i<n;i++){
            int j=i;
            while(j<n &&nums[j]==0) j++;
            if(j<n) nums[pos++]=nums[j];
            i=j;
        }
        while(pos<n) nums[pos++]=0;
    }
```

## [844. 比较含退格的字符串-栈](https://leetcode.cn/problems/backspace-string-compare/)

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

### 思路

直接模拟即可：

如果遇到字符，压入栈中

如果不是字符，并且栈中有元素，那么就弹出来。

也可以使用双指针。

### 代码

```cpp
    bool backspaceCompare(string s, string t) {
        string x, y;
        for (auto c: s) {
            if (c == '#') {
                if (!x.empty()) x.pop_back();
            } else x.push_back(c);
        }
        for (auto c: t) {
            if (c == '#') {
                if (!y.empty()) y.pop_back();
            } else y.push_back(c);
        }
        return x == y;
    }
```

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

### 题目

把每个数平方之后排个序即可

或者可以 使用 双指针，最大值只会 产生在 两边，每次只需要 从两边选 较大的即可。

### 代码

排序

```cpp
    vector<int> sortedSquares(vector<int>& nums) {
        for(int i=0;i<nums.size();i++) nums[i]=nums[i]*nums[i];
        sort(nums.begin(),nums.end());
        return nums;
    }
```

双指针：

```cpp
    vector<int> sortedSquares(vector<int>& nums) {
        int n=nums.size();
        vector<int> res(n);
        for(int i=0;i<n;i++) nums[i]=nums[i]*nums[i];
        for(int l=0,r=n-1,pos=n-1;l<=r;){
            if(nums[l]>nums[r]) res[pos--]=nums[l++];
            else res[pos--]=nums[r--];
        }
        return res;
    }
```

