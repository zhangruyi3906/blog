import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,d as t}from"./app-BDwQ7LXr.js";const e={},p=t(`<h1 id="rabbitmq面试题" tabindex="-1"><a class="header-anchor" href="#rabbitmq面试题"><span>RabbitMQ面试题</span></a></h1><h2 id="rabbitmq如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#rabbitmq如何保证消息不丢失"><span>RabbitMQ如何保证消息不丢失</span></a></h2><blockquote><p>出现消息丢失可能会出现在以下场景：</p><ul><li>异步发送（验证码，短信，邮件）</li><li>MySQL和Redis，ES之间的数据同步</li><li>分布式事务</li><li>削峰消谷</li></ul><p>总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息</p><ol><li>解决办法：生产者确认机制：</li></ol><p>生产者确认机制是指生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。</p><p>消息失败之后如何处理呢？</p><ul><li>回调方法即时重发</li><li>记录日志</li><li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据</li></ul><p>MQ宕机导致消息丢失：</p><ol start="2"><li>解决办法：消息持久化</li></ol><p>MQ默认是内存存储消息，开启持久化可以确保缓存中MQ消息不丢失</p><p>主要是交换机，队列，消息持久化</p><p>交换机持久化</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">simpleExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//三个参数分别是：交换机名称，durable是否持久化，autoDelete是否自动删除</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">&quot;simple.direct&quot;</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>队列持久化</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">simpleQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//使用QueueBuilder创建队列，durable就是持久化</span>
    <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;simple.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消息持久化,通过MessageDeliveryMode.PERSISTENT实现</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span>
        <span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 持久化消息</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>解决办法消费者确认机制</li></ol><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP.则允许配置三种确认模式：</p><ul><li>manual:手动ack,需要在业务代码结束后，调用api发送ack。</li><li>auto:自动ack,由spring监测listener代码是香出现异常，没有异常则返回ack;抛出异常则返回nack</li><li>none:关闭ack,MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li></ul><p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p><p><img src="https://s2.loli.net/2024/02/17/dj2frmUs1uLhOvK.webp" alt="image-20240217082251946"></p></blockquote><p>回答：</p><ul><li>开启生产者确认机制，确保生产者的消息能到达队列</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失</li><li>开启消费者确认机制为auto,由spring确认消息处理成功后完成ack</li><li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li></ul><h2 id="rabbitmq消息的重复消费问题如何解决" tabindex="-1"><a class="header-anchor" href="#rabbitmq消息的重复消费问题如何解决"><span>RabbitMQ消息的重复消费问题如何解决</span></a></h2><blockquote><p>消息重复消费出现场景：</p><ul><li>网络抖动导致消息投递失败，RabbitMQ会重试投递消息。</li><li>消费者在处理消息过程中发生异常，导致消息未被确认，RabbitMQ会重新投递消息。</li><li>负载均衡导致消息被多个消费者消费。</li></ul></blockquote><p>解决办法：</p><ul><li>每条消息设置一个唯一的标识id</li><li>幂等方案：分布式锁、数据库锁（悲观锁、乐观锁）</li></ul><h2 id="rabbitmq中死信交换机-延迟队列有了解过吗" tabindex="-1"><a class="header-anchor" href="#rabbitmq中死信交换机-延迟队列有了解过吗"><span>RabbitMQ中死信交换机（延迟队列有了解过吗）</span></a></h2><blockquote><p>死信交换机是 RabbitMQ 中的一个特殊交换机，用于处理无法投递的消息。当消息无法投递到任何队列时，它会被路由到死信交换机。死信交换机可以将消息路由到另一个队列或执行其他操作。</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信(dead letter):</p><ul><li>消费者使用basic.reject或basic..nack声明消费失败，并且消息的requeue:参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul><p>延迟队列是一种特殊的队列，消息在队列中会等待一段指定的时间后才会被投递给消费者。</p><p>场景：超时订单，限时优惠，定时发布</p><p>TTL,也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，tt超时分为两种情况：</p><ul><li>消息所在的队列设置了存活时间</li><li>消息本身设置了存活时间</li></ul><p>Delay Exchange插件：使用时只需要声明一个交换机，delayed属性为true即可</p></blockquote><p>回答：</p><ul><li>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布.…）</li><li>其中延迟队列就用到了死信交换机和TTL(消息存活时间)实现的</li><li>消息超时未消费就会变成死信（死信的其他情况：拒绝被消费，队列满了）</li></ul><p>延迟队列插件实现延迟队列DelayExchange</p><ul><li>声明一个交换机，添加delayed属性为true</li><li>发送消息时，添加x-delay头，值为超时时间</li></ul><h2 id="如果有100万消息堆积在mq-如何解决" tabindex="-1"><a class="header-anchor" href="#如果有100万消息堆积在mq-如何解决"><span>如果有100万消息堆积在MQ , 如何解决 ?</span></a></h2><blockquote><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列<br> 存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p><p>解决消息堆积有三种种思路：</p><ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限</li></ul><p>惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul></blockquote><p>回答：</p><p>解决消息堆积有三种种思路：</p><ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限，采用惰性队列 <ul><li>在声明队列的时候可以设置属性x-queue-mode为lazy,即为惰性队列</li><li>基于磁盘存储，消息上限高</li><li>性能比较稳定，但基于磁盘存储，受限于磁盘O,时效性会降低</li></ul></li></ul><h2 id="rabbitmq的高可用机制有了解过嘛" tabindex="-1"><a class="header-anchor" href="#rabbitmq的高可用机制有了解过嘛"><span>RabbitMQ的高可用机制有了解过嘛</span></a></h2><blockquote><p>在生产环境下，使用集群来保证高可用性</p><ul><li>普通集群、镜像集群、仲裁队列</li></ul><p><strong>RabbitMQ</strong> 提供了多种高可用机制来确保消息队列的可靠性和稳定性，包括：</p><p><strong>1. 普通集群</strong></p><p>普通集群模式会在各个节点间共享部分数据（交换机和队列元信息），但不包含队列里的消息；如果队列不在该节点，会从数据所在节点传递到当前节点并返回；当所在节点宕机，队列中的消息就会丢失。</p><p><strong>2. 镜像集群</strong></p><p>镜像集群本质是主从模式。镜像集群特征如下：</p><ul><li>交换机、队列、队列中的消息会在各个MQ的镜像节点之间同步备份。</li></ul><ul><li>创建队列的节点称为该队列的主节点，备份的其他节点叫该队列的镜像节点。</li><li>一个队列的主节点可能是另一个队列的镜像节点。</li></ul><p><strong>3. 仲裁队列</strong></p><p>仲裁队列用于解决镜像集群中主节点故障时的数据一致性问题。仲裁队列使用 Raft 协议保证强一致性。</p></blockquote><p>回答：</p><ul><li>在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点</li><li>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li></ul><p>出现数据丢失如何解决：我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Rft协议，强一致。并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p>`,25),l=[p];function i(o,c){return n(),s("div",null,l)}const d=a(e,[["render",i],["__file","RabbitMQ面试题.html.vue"]]),b=JSON.parse('{"path":"/java/5-%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"RabbitMQ面试题","lang":"en-US","frontmatter":{"title":"RabbitMQ面试题","date":"2024-02-17T00:00:00.000Z","category":["中间件","RabbitMQ"],"tag":["中间件","RabbitMQ"],"description":"RabbitMQ面试题 RabbitMQ如何保证消息不丢失 出现消息丢失可能会出现在以下场景： 异步发送（验证码，短信，邮件） MySQL和Redis，ES之间的数据同步 分布式事务 削峰消谷 总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息 解决办法：生产者确认机制： 生产者确认机制是指生产者发送消息后，需要等待Rabbi...","head":[["meta",{"property":"og:url","content":"https://github.com/zhangruyi3906/blog/java/5-%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"乘风破浪（长风破浪会有时，直挂云帆济沧海）"}],["meta",{"property":"og:title","content":"RabbitMQ面试题"}],["meta",{"property":"og:description","content":"RabbitMQ面试题 RabbitMQ如何保证消息不丢失 出现消息丢失可能会出现在以下场景： 异步发送（验证码，短信，邮件） MySQL和Redis，ES之间的数据同步 分布式事务 削峰消谷 总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息 解决办法：生产者确认机制： 生产者确认机制是指生产者发送消息后，需要等待Rabbi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s2.loli.net/2024/02/17/dj2frmUs1uLhOvK.webp"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-14T07:14:40.000Z"}],["meta",{"property":"article:author","content":"dreamchaser"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:tag","content":"RabbitMQ"}],["meta",{"property":"article:published_time","content":"2024-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-14T07:14:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ面试题\\",\\"image\\":[\\"https://s2.loli.net/2024/02/17/dj2frmUs1uLhOvK.webp\\"],\\"datePublished\\":\\"2024-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-14T07:14:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"dreamchaser\\",\\"url\\":\\"https://github.com/zhangruyi3906\\"}]}"]]},"headers":[{"level":2,"title":"RabbitMQ如何保证消息不丢失","slug":"rabbitmq如何保证消息不丢失","link":"#rabbitmq如何保证消息不丢失","children":[]},{"level":2,"title":"RabbitMQ消息的重复消费问题如何解决","slug":"rabbitmq消息的重复消费问题如何解决","link":"#rabbitmq消息的重复消费问题如何解决","children":[]},{"level":2,"title":"RabbitMQ中死信交换机（延迟队列有了解过吗）","slug":"rabbitmq中死信交换机-延迟队列有了解过吗","link":"#rabbitmq中死信交换机-延迟队列有了解过吗","children":[]},{"level":2,"title":"如果有100万消息堆积在MQ , 如何解决 ?","slug":"如果有100万消息堆积在mq-如何解决","link":"#如果有100万消息堆积在mq-如何解决","children":[]},{"level":2,"title":"RabbitMQ的高可用机制有了解过嘛","slug":"rabbitmq的高可用机制有了解过嘛","link":"#rabbitmq的高可用机制有了解过嘛","children":[]}],"git":{"createdTime":1718196522000,"updatedTime":1718349280000,"contributors":[{"name":"zhangruyi3906","email":"3023208132@qq.com","commits":3}]},"readingTime":{"minutes":7.23,"words":2169},"filePathRelative":"java/5-中间件/RabbitMQ面试题.md","localizedDate":"February 17, 2024","excerpt":"\\n<h2>RabbitMQ如何保证消息不丢失</h2>\\n<blockquote>\\n<p>出现消息丢失可能会出现在以下场景：</p>\\n<ul>\\n<li>异步发送（验证码，短信，邮件）</li>\\n<li>MySQL和Redis，ES之间的数据同步</li>\\n<li>分布式事务</li>\\n<li>削峰消谷</li>\\n</ul>\\n<p>总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息</p>\\n<ol>\\n<li>解决办法：生产者确认机制：</li>\\n</ol>\\n<p>生产者确认机制是指生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。</p>\\n<p>消息失败之后如何处理呢？</p>\\n<ul>\\n<li>回调方法即时重发</li>\\n<li>记录日志</li>\\n<li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据</li>\\n</ul>\\n<p>MQ宕机导致消息丢失：</p>\\n<ol start=\\"2\\">\\n<li>解决办法：消息持久化</li>\\n</ol>\\n<p>MQ默认是内存存储消息，开启持久化可以确保缓存中MQ消息不丢失</p>\\n<p>主要是交换机，队列，消息持久化</p>\\n<p>交换机持久化</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token annotation punctuation\\">@Bean</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">DirectExchange</span> <span class=\\"token function\\">simpleExchange</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//三个参数分别是：交换机名称，durable是否持久化，autoDelete是否自动删除</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">DirectExchange</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"simple.direct\\"</span><span class=\\"token punctuation\\">,</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">,</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div><p>队列持久化</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token annotation punctuation\\">@Bean</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">Queue</span> <span class=\\"token function\\">simpleQueue1</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//使用QueueBuilder创建队列，durable就是持久化</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token class-name\\">QueueBuilder</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">durable</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"simple.queue1\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">build</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div><p>消息持久化,通过MessageDeliveryMode.PERSISTENT实现</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token class-name\\">Message</span> message <span class=\\"token operator\\">=</span> <span class=\\"token class-name\\">MessageBuilder</span>\\n        <span class=\\"token punctuation\\">.</span><span class=\\"token function\\">withBody</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"hello\\"</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getBytes</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">StandardCharsets</span><span class=\\"token punctuation\\">.</span><span class=\\"token constant\\">UTF_8</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span>\\n        <span class=\\"token punctuation\\">.</span><span class=\\"token function\\">setDeliveryMode</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">MessageDeliveryMode</span><span class=\\"token punctuation\\">.</span><span class=\\"token constant\\">PERSISTENT</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">build</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">// 持久化消息</span>\\n</code></pre></div><ol start=\\"3\\">\\n<li>解决办法消费者确认机制</li>\\n</ol>\\n<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP.则允许配置三种确认模式：</p>\\n<ul>\\n<li>manual:手动ack,需要在业务代码结束后，调用api发送ack。</li>\\n<li>auto:自动ack,由spring监测listener代码是香出现异常，没有异常则返回ack;抛出异常则返回nack</li>\\n<li>none:关闭ack,MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>\\n</ul>\\n<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>\\n<p><img src=\\"https://s2.loli.net/2024/02/17/dj2frmUs1uLhOvK.webp\\" alt=\\"image-20240217082251946\\"></p>\\n</blockquote>","autoDesc":true}');export{d as comp,b as data};
