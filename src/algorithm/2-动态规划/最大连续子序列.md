---
title: 最大连续子序列
date: 2023-04-10 18:14:16
category: 
  - Algorithm
  - 动态规划
tag:
  - Algorithm
  - 动态规划
---

# [最大连续子序列](https://www.acwing.com/problem/content/description/3655/)

给定 K 个整数的序列 {N0,N1,…,NK−1} ，其任意连续子序列可表示为 {Ni,Ni+1,…,Nj} ，其中 0≤i≤j<K 。

最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列 {−2,11,−4,13,−5,−2} ，其最大连续子序列为 {11,−4,13} ，最大和为 20 。

编写程序得到其中最大子序列的和并输出该子序列的第一个和最后一个元素的下标。

## 输入格式 

输入包含多组测试数据。

每组数据占 2 行，第 1 行给出正整数 K 。

第 2 行给出 K 个整数 N1,…,NK 。

## 输出格式

 每组数据输出一行结果，包含最大子序列的和以及子序列的第一个下标 i 和最后一个元素的下标 j 。

所有元素下标为 0∼K−1 。

如果最大子序列不唯一，则选择 i 最小的那个子序列，如果仍不唯一，则选择 i 最小的子序列中 j 最小的那个子序列。

若所有 K 个元素都是负数，则定义其最大和为 0 ，输出 0 0 0。

## 数据范围

 1≤K≤105 , −10000≤Ni≤10000 , 输入最多包含 10 组数据。

## 思路

动态规划：

+ 状态表示：`f[i]`表示以第i个数结尾的子序列的最大值。
+ 状态计算：
  + 如果 `f[i-1]<0`,那么以第i个数结尾的子序列的最大值就是自己，因为加上前面的就会变小
  + 如果`f[i-1]>=0`,则`f[i]=f[i-1]+a[i]`

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;


signed main() {
#ifndef ONLINE_JUDGE
    freopen("../test.in", "r", stdin);
    freopen("../test.out", "w", stdout);
#endif
    int n;
    while (cin >> n) {
        vector<int> a(n + 1), f(n + 1);
        //f[i]表示以第i个数结尾的子序列的最大值。
        for (int i = 1; i <= n; i++) cin >> a[i];
        int res = -1, l = 0, r = 0, temp = 1;
        for (int i = 1; i <= n; i++) {
            if (f[i - 1] >= 0) {
                f[i] = f[i - 1] + a[i];
            } else {
                f[i] = a[i];
                temp = i;
            }
            if (f[i] > res) {
                l = temp;
                r = i;
                res = f[i];
            }
        }
        if (res == -1) {
            res = 0, l = 1, r = 1;
        }
        cout << res << " " << l - 1 << ' ' << r - 1 << endl;
    }
    return 0;
}
```

