---
title: 数字三角形模型
date: 2023-05-10 14:26:11
category: 
  - Algorithm
  - 动态规划
tag:
  - Algorithm
  - 动态规划
---

# [数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)

## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

```cpp
        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5 
```
在上面的样例中,从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大

## 输入格式

第一个行一个正整数 $r$ ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

## 输出格式

单独的一行,包含那个可能得到的最大的和。

## 样例 #1

### 样例输入 #1

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 样例输出 #1

```
30
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

## 思路

状态表示：`f[i][j]`表示从(1,1)走到(i,j)的最大值

每个位置是由上面两个位置递归过来，因此`f[i][j]=max(f[i-1][j-1],f[i-1][j])`

## 代码-递推

```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;

const int N = 1010;
int n;
int a[N][N];
int f[N][N];

signed main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> a[i][j];
            f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
        }
    }
    int t = -1;
    for (int i = 1; i <= n; i++) {
        t = max(t, f[n][i]);
    }
    cout << t << endl;
    return 0;
}
```

## 记忆化搜索-递归

```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;

const int N = 1010;
int n;
int a[N][N];
int f[N][N]; //记录从下到上累加和

int dfs(int x, int y) {
    if (f[x][y] != -1) return f[x][y]; //记忆化，避免进一步递归
    if (x == n) f[x][y] = a[x][y];
    else f[x][y] = max(dfs(x + 1, y), dfs(x + 1, y + 1)) + a[x][y];
    return f[x][y];
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> a[i][j];
        }
    }
    memset(f,-1,sizeof f);
    dfs(1, 1);
    cout << f[1][1];
    return 0;
}
```



# [[NOIP2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

```plain
A
 0  0  0  0  0  0  0  0
 0  0 13  0  0  6  0  0
 0  0  0  0  7  0  0  0
 0  0  0 14  0  0  0  0
 0 21  0  0  0  4  0  0
 0  0 15  0  0  0  0  0
 0 14  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
                         B
```
某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。

## 输入格式

输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。

## 输出格式

只需输出一个整数，表示 $2$ 条路径上取得的最大的和。

## 样例 #1

### 样例输入 #1

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 样例输出 #1

```
67
```

## 思路

可以直接定义四维数组:`f[N][N][N][N]`:

`f[x1][y1][x2][y2]`表示同时走，走到(x1,y1),(x2,y2)的最大值

满足：x1+y1=x2+y2;

转移：

+ 左，左
+ 左，上
+ 上，左
+ 上，上

三维优化：

我们可以设两个人同时出发，从A点走到B点，此时需要维护当前两条路径的状态，也就是`f[x1][y1][x2][y2]`,但是考虑到，两个人同时走，所有他们走的步数是相同的，也就是可以设`k=x1+y1=x2+y2`,所以可以优化为三个维度`f[k][x1][x2]`来维护，此时`y1=k-x1`,`y2=k-x2`

两个小朋友同时走, 每个人走的步数和是一样的.

动态规划：

- 状态表示：`f[k][x1][x2]`

- - 集合：同时走k步，所有从`(1,1),(1,1)`走到`(x1,y1),(x2,y2)`能获得的花生的数目
  - 属性：Max

- 状态计算：

- - 第一个从左边，第二个从左边：`f[k-1][x1-1][x2-1]`
  - 第一个从左边，第二个从上边：`f[k-1][x1-1][x2]`
  - 第一个从上边，第二个从左边：`f[k-1][x1][x2-1]`
  - 第一个从上边，第二个从上边：`f[k-1][x1][x2]`

注意：

- 需要判断两个人是否走到同一个格子上面:`x1==x2?`

## 代码

四维：

```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;

const int N = 20;
int g[N][N];
int f[N][N][N][N];
int n;

signed main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    cin >> n;
    int a, b;
    while (cin >> a >> b >> g[a][b], a);
    for (int x1 = 1; x1 <= n; x1++) {
        for (int y1 = 1; y1 <= n; y1++) {
            for (int x2 = 1; x2 <= n; x2++) {
                for (int y2 = 1; y2 <= n; y2++) {
                    int &x = f[x1][y1][x2][y2];
                    x = max(x, f[x1 - 1][y1][x2 - 1][y2]);
                    x = max(x, f[x1 - 1][y1][x2][y2 - 1]);
                    x = max(x, f[x1][y1 - 1][x2 - 1][y2]);
                    x = max(x, f[x1][y1 - 1][x2][y2 - 1]);
                    if (x1 == x2 && y1 == y2) x += g[x1][y1];
                    else x += g[x1][y1] + g[x2][y2];
                }
            }
        }
    }
    cout << f[n][n][n][n];

    return 0;
}
```

三维：

```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;

const int N = 20;
int g[N][N];
//f[k][x1][x2] 表示同时走k步，从1，1走到 x1,y1 x2,y2可以得到的花生的最大数量
int f[N][N][N];
int n;

signed main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    cin >> n;
    int a, b, c;
    while (cin >> a >> b >> c, a || b || c)g[a][b] = c;

    for (int k = 2; k <= 2 * n; k++) {
        for (int x1 = 1; x1 <= n; x1++) {
            for (int x2 = 1; x2 <= n; x2++) {
                int y1 = k - x1, y2 = k - x2;
                if (y1 >= 1 && y1 <= n && y2 >= 1 && y2 <= n) {
                    int t = g[x1][y1];
                    if (x1 != x2) t += g[x2][y2];
                    int &x = f[k][x1][x2];
                    x = max(x, f[k - 1][x1 - 1][x2 - 1] + t);
                    x = max(x, f[k - 1][x1 - 1][x2] + t);
                    x = max(x, f[k - 1][x1][x2 - 1] + t);
                    x = max(x, f[k - 1][x1][x2] + t);
                }
            }
        }
    }
    cout << f[n + n][n][n] << endl;

    return 0;
}
```





# AcWing 1015. 摘花生

## 题目

题目链接：https://www.acwing.com/problem/content/1017/

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![img](https://cdn.nlark.com/yuque/0/2023/png/28600854/1675039693767-a417e190-005b-468a-a98c-19d6630221a0.png)

## 思路

动态规划：

- 状态表示：`f[i][j]`

- - 集合：所有从`(1,1)`走到`(i,j)`的路线
  - 属性：`Max`

- 状态计算：集合的划分(很重要的依据：`“最后”`)

- - 最后一步是从上面下来的：`f[i-1][j]+w[i][j]`
  - 最后一步是从左边过来的：`f[i][j-1]+w[i][j]`

- 状态转移方程：`f[i][j]=max(f[i-1][j],f[i][j-1])+w[i][j]`

## 代码

```java
#include<iostream>
#include<algorithm>
using namespace std;

const int N=110;
int n,m;
int w[N][N];
int f[N][N];

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                scanf("%d",&w[i][j]);
                
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                f[i][j]=max(f[i-1][j],f[i][j-1])+w[i][j];
        printf("%d\n",f[n][m]);
    }
    return 0;
}
```

# AcWing 1018. 最低通行费

## 题目

题目链接：https://www.acwing.com/problem/content/1020/

一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 1 个小方格，都要花费 1 个单位时间。

商人必须在 (2N−1) 个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

## 思路

2N-1表示只能向右和向下走，不能回头

动态规划：

- 状态表示：`f[i][j]`

- - 集合：从起点出发，走到第`i`行`j`列的所有方案
  - 属性：方案中经过所有路线的最小值

- 状态计算：

- - 注意：

- - - 只有不在第一行的时候，才可以从上面走下来
    - 只有不在第一列的时候，才可以从左边走过来

- - 最后一步是从上面下来的：`f[i-1][j]+w[i][j]`
  - 最后一步是从左边过来的：`f[i][j-1]+w[i][j]`

- 状态转移方程：`f[i][j]=min(f[i-1][j],f[i][j-1])+w[i][j]`

## 代码

```java
#include<iostream>
using namespace std;

const int N=110,INF=1e9;
int w[N][N];
int f[N][N];

int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&w[i][j]);
    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i==1&&j==1) f[i][j]=w[i][j];//特判左上角
            else
            {
                f[i][j]=INF;
                if(i>1) f[i][j]=min(f[i][j],f[i-1][j]+w[i][j]);//只有不在第一行的时候，才可以从上面下来
                if(j>1) f[i][j]=min(f[i][j],f[i][j-1]+w[i][j]);//只有不在第一列的时候，才可以从左边过来
            }
    printf("%d",f[n][n]);
    return 0;
}
```

# [NOIP2008 提高组 传纸条](https://www.luogu.com.cn/problem/P1006)

## 题目描述

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。

## 输入格式

第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。

接下来的 $m$ 行是一个 $m \times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。

## 输出格式

输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

## 样例 #1

### 样例输入 #1

```
3 3
0 3 9
2 8 5
5 7 0
```

### 样例输出 #1

```
34
```

## 提示

**【数据范围】**

对于 $30\%$ 的数据，满足 $1 \le m,n \le 10$。  
对于 $100\%$ 的数据，满足 $1 \le m,n \le 50$。

**【题目来源】**

NOIP 2008 提高组第三题。

## 思路

从右下角回来可以等价于从左上角走下去，题目就转换为从左上角同时走两条不相交的路线到右下角的权值的最大值。

状态表示：`f[k][x1][x2]`表示同时走`k`步，所有从`(1,1),(1,1)`走到`(x1,y1),(x2,y2)`得到的权值的最大值。

状态计算：

- 第一个从左边，第二个从左边：`f[k-1][x1-1][x2-1]`	
- 第一个从左边，第二个从上边：`f[k-1][x1-1][x2]`
- 第一个从上边，第二个从左边：`f[k-1][x1][x2-1]`
- 第一个从上边，第二个从上边：`f[k-1][x1][x2]`

注意：不能走到一个格子里，因为最优解一定不会相交，一定可以绕开这个点向其他地方走。

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long
using namespace std;

const int N = 100;
int n, m;
int f[N * 2][N][N];
int g[N][N];

signed main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> g[i][j];
        }
    }
    for (int k = 2; k <= n + m; k++) {
        for (int x1 = 1; x1 < k; x1++) {
            for (int x2 = 1; x2 < k; x2++) {
                int y1 = k - x1, y2 = k - x2;
                if (y1 < 1 || y1 > m || y2 < 1 || y2 > m) continue;
                int &x = f[k][x1][x2];
                x = max(x, f[k - 1][x1][x2]);
                x = max(x, f[k - 1][x1][x2 - 1]);
                x = max(x, f[k - 1][x1 - 1][x2]);
                x = max(x, f[k - 1][x1 - 1][x2 - 1]);
                if (x1 == x2 && y1 == y2) x += g[x1][y1];
                else x += g[x1][y1] + g[x2][y2];
            }
        }
    }
    cout << f[n + m][n][n];
    return 0;
}
```



