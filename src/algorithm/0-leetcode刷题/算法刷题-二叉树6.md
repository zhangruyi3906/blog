---
title: 算法刷题-二叉树6
date: 2023-11-04
category:
  - 草稿
tag:
  - 草稿
---
# 算法刷题-二叉树6

## [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
给你两棵二叉树： `root1` 和 `root2` 。
想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。
返回合并后的二叉树。
**注意:** 合并过程必须从两个树的根节点开始。

### 思路
这道题的思路是通过递归的方式合并两个二叉树。
具体步骤如下：
1. 首先判断两个根节点 `root1` 和 `root2` 是否为空，如果其中一个为空，则返回另一个非空的根节点。
2. 创建一个新的根节点 `root`，其值为 `root1` 和 `root2` 值的和。
3. 递归调用 `mergeTrees` 方法，将 `root1` 的左子树和 `root2` 的左子树合并，并将结果赋值给 `root` 的左子树。
4. 递归调用 `mergeTrees` 方法，将 `root1` 的右子树和 `root2` 的右子树合并，并将结果赋值给 `root` 的右子树。
5. 返回合并后的二叉树 `root`。
通过递归的方式，可以将两个二叉树的节点逐个合并，最终得到合并后的二叉树。

### 代码
```python
# Definition for a binary tree node.
from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if not root2:
            return root1
        root = TreeNode(root1.val + root2.val)
        root.left = self.mergeTrees(root1.left, root2.left)
        root.right = self.mergeTrees(root1.right, root2.right)
        return root

```


## [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。


### 思路

深度优先搜索（DFS）
1. 首先定义一个内部函数dfs，它接受一个根节点作为参数。在dfs函数中，首先判断当前节点是否为空，如果为空则返回None。
2. 然后判断当前节点的值与目标值val的大小关系，如果当前节点的值大于val，则递归调用dfs函数搜索左子树；如果当前节点的值小于val，则递归调用dfs函数搜索右子树；如果当前节点的值等于val，则返回当前节点。
3. 最后，在searchBST函数中调用dfs函数，并返回其结果。
### 代码

```python
# Definition for a binary tree node.
from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        def dfs(root):
            if not root:
                return None
            if root.val > val:
                return dfs(root.left)
            if root.val < val:
                return dfs(root.right)
            return root
        return dfs(root)

```


## [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。


### 思路

深度优先搜索（DFS）。
1. 首先定义一个内部函数dfs，它接受一个根节点和上界和下界作为参数。在dfs函数中，首先判断当前节点是否为空，如果为空则返回True。然后获取当前节点的值，并与上界和下界进行比较，如果当前节点的值小于等于下界或大于等于上界，则返回False。
2. 接着递归调用dfs函数判断左子树是否是BST，如果返回False，则直接返回False。再递归调用dfs函数判断右子树是否是BST，如果返回False，则直接返回False。
3. 最后，如果左右子树都是BST，则返回True。在isValidBST函数中调用dfs函数，并返回其结果。
### 代码

```python
# Definition for a binary tree node.
from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs(root, lower=float('-inf'), upper=float('inf')):
            if not root:
                return True
            val = root.val
            if val <= lower or val >= upper:
                return False
            if not dfs(root.left, lower, val):
                return False
            if not dfs(root.right, val, upper):
                return False
            return True
        return dfs(root)

```
