---
title: 算法刷题-二叉树4
date: 2023-11-02
category:
  - Algorithm
  - 二叉树
tag:
  - Algorithm
  - 二叉树
---
# 算法刷题-二叉树4

## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
### 思路
翻转二叉树的问题。首先判断根节点是否为空，如果为空则直接返回。然后交换根节点的左右子节点，再递归地对左右子树进行翻转操作。最后返回根节点。
### 代码

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return root
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
### 思路

首先判断根节点是否为空，如果为空则直接返回True。然后调用dfs函数来判断左右子树是否对称。在dfs函数中，
1. 首先判断左右子节点是否为空，如果一个为空而另一个不为空，则返回False。
2. 然后判断左右子节点的值是否相等，如果不相等则返回False。
3. 接着递归地对左子树的左节点和右子树的右节点进行判断，同时对左子树的右节点和右子树的左节点进行判断。
4. 如果两个递归返回都是true，说明她们对称
### 代码
```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        return self.dfs(root.left,root.right)

    def dfs(self, left: TreeNode, right: TreeNode):
        if left is None and right:
            return False
        elif left and right is None:
            return False
        elif left is None and right is None:
            return True
        elif left.val != right.val:
            return False

        outside = self.dfs(left.left, right.right)
        inside = self.dfs(left.right, right.left)
        return outside and inside
```

## [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。
### 思路
初始化队列并将根节点加入队列中。然后进入循环，每次循环开始前先记录当前队列的长度，表示当前层的节点个数。然后通过循环遍历当前层的节点，每遍历一个节点，计数器cnt加1。同时，如果当前节点有左子节点，则将左子节点加入队列；如果当前节点有右子节点，则将右子节点加入队列。最后返回计数器cnt的值，即为二叉树的节点个数。
### 代码

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        queue = collections.deque([root])
        cnt = 0
        while queue:
            sz = len(queue)
            for i in range(sz):
                node = queue.popleft()
                cnt += 1
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return cnt
```

## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。


### 思路

平衡二叉树是指对于任意一个节点，它的左子树和右子树的高度差不超过1。
这里使用深度优先搜索（DFS）的方法来解决：
+ 首先定义一个辅助函数dfs，它返回当前节点的高度。在dfs函数中，先递归计算左子树的高度，再递归计算右子树的高度。
+ 如果左子树或右子树的高度差超过1，或者左子树或右子树不是平衡二叉树，则返回-1表示不是平衡二叉树。
+ 否则，返回左子树和右子树中较大的高度加1。
+ 最后，在isBalanced函数中，判断根节点的高度是否大于等于0，如果是则返回True，否则返回False。
### 代码

```python
# Definition for a binary tree node.
from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.dfs(root) >= 0

    def dfs(self, root: TreeNode) -> int:
        if root is None:
            return 0
        leftHeight = self.dfs(root.left)
        rightHeight = self.dfs(root.right)
        if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) > 1:
            return -1
        else:
            return max(leftHeight, rightHeight) + 1

```

## [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。


### 思路

使用深度优先搜索（DFS）的方法来解决。
+ 首先定义一个辅助函数dfs，它接收当前节点cur、当前路径path和结果列表result作为参数。
+ 在dfs函数中，先将当前节点的值加入到路径path中。然后判断当前节点是否为叶子节点，如果是，则将路径path转换为字符串，并将其加入到结果列表result中。
+ 接着，分别递归处理当前节点的左子树和右子树，注意要传入路径path的副本，以免在不同的递归中共享同一个路径。
+ 最后，在binaryTreePaths函数中，判断根节点是否为空，如果是，则直接返回空列表。否则，创建一个空的结果列表res，并调用dfs函数来进行深度优先搜索。最后返回结果列表res即可。
### 代码

```python
# Definition for a binary tree node.
from typing import Optional, List


# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if root is None:
            return []
        res = []
        self.dfs(root, [], res)
        return res

    def dfs(self, cur: TreeNode, path: List[int], result: List[str]):
        if cur is None:
            return
        path.append(cur.val)
        if not cur.left and not cur.right:
            result.append('->'.join(map(str, path)))
        if cur.left:
            self.dfs(cur.left, path[:], result)
        if cur.right:
            self.dfs(cur.right, path[:], result)





```
