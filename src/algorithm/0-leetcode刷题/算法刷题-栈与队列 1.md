---
title: 算法刷题-栈与队列
date: 2023-10-28
category:
  - Algorithm
  - 栈与队列
tag:
  - Algorithm
  - 栈与队列
---
# 算法刷题-栈与队列

## [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

### 思路

逆波兰表达式：是一种后缀表达式,好处就是适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

1. 创建一个空栈来存储操作数。
2. 遍历逆波兰表达式中的每个元素（字符串）。
3. 对于每个元素，进行以下操作：
    - 如果它是一个操作数（即数字），则将其转换为整数并推入栈中。
    - 如果它是一个操作符（+、-、\*、/），则从栈中弹出两个操作数，执行相应的运算，并将结果推回栈中。
4. 遍历完成后，栈中仅剩一个元素，即整个表达式的结果。

### 代码


```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> sk;
        for(string s:tokens){
            if(s=="+"||s=="-"||s=="*"||s=="/"){
                long long a=sk.top();
                sk.pop();
                long long b=sk.top();
                sk.pop();
                if(s=="+") sk.push(a+b);
                if(s=="-") sk.push(b-a);
                if(s=="*") sk.push(a*b);
                if(s=="/") sk.push(b/a);
            }else{
                sk.push(stoll(s));
            }
        }
        return sk.top();
    }
};
```


## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 _滑动窗口中的最大值_ 。

### 思路

在C++中，可以使用multiset这种数据结构作为单调队列
>多重集合(`multiset`) 用以有序地存储元素的容器。允许存在相等的元素。

随着窗口的移动，每次将窗口的头元素加入到multiset中，并且删除尾元素，multiset的`*rbegin()`
就是整个窗口的最大值
### 代码
```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        multiset<int> st;
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= k) st.erase(st.find(nums[i - k]));
            st.insert(nums[i]);
            if (i >= k - 1) ans.push_back(*st.rbegin());
        }
        return ans;
    }
};
```

## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

### 思路

先使用map记录每个元素出现的频率，然后把map转为vector，再对vector进行排序，调用自定义排序函数，根据第二个元素的大小进行排序，然后再取出前k大大元素。
### 代码
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        map<int,int> m;
        for(int x:nums) m[x]++;
        vector<pair<int,int>> t;
        for(auto [x,y]:m) t.push_back({x,y});
        sort(t.begin(),t.end(),[&](pair<int,int> a,pair<int,int> b){
            return a.second>b.second;
        });
        vector<int> res;
        for(int i=0;i<k;i++) res.push_back(t[i].first);
        return res;
    }
};
```
