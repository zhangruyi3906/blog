---
title: 算法刷题-数组二分
date: 2023-10-18
category:
  - Algorithm
  - 数组
tag:
  - Algorithm
  - 数组 
---

# 算法刷题-数组

## 704.二分查找-二分算法

https://leetcode.cn/problems/binary-search/description/

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
**示例 1:**

```cpp
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```cpp
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

### 思路

二分查找，找第一个大于等于target的数的位置，使用模版即可或者也可以使用stl里面自带的lower_bound函数

当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。

找满足check条件的最小位置

```cpp
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。

找满足check条件的最大位置

```cpp
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 代码

```cpp
    int search(vector<int> &nums, int target) {
        int n = nums.size();
        int l = 0, r = n - 1;
        //找第一个>=target的数字的位置
        while (l < r) {
            int mid = (l + r) >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) l = -1;
        return l;
    }
```

或者

```cpp
int search(vector<int> &nums, int target) {
    int idx = std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();
    if (idx == nums.size()||nums[idx]!=target) idx = -1;
    return idx;
}
```



## 35-搜索插入位置-二分

https://leetcode.cn/problems/search-insert-position/description/

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

### 思路

跟上一题一样，找到第一个大于等于目标值的元素的位置就是答案。

### 代码

```cpp
    int searchInsert(vector<int> &nums, int target) {
        int idx = std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        return idx;
    }
```

## 34. 在排序数组中查找元素的第一个和最后一个位置-二分

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/

### 思路

可以按照第一题里面的两个模版，一个是找最大位置，还有一个是找最小位置

或者可以使用c++的stl库函数，lower_bound 和upper_bound函数 

### 代码

```cpp
    vector<int> searchRange(vector<int> &nums, int target) {
        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;
        if (l == nums.size() || nums[l] != target) {
            return {-1, -1};
        }
        return {l, r};
    }
```

## [69. x 的平方根-二分](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

https://leetcode.cn/problems/sqrtx/description/

### 思路

找满足条件(t*t<=x)的最大的t即可，可以使用第一题的第二个模

### 代码

```cpp
class Solution {
public:
    int mySqrt(int x) {
        long long l = 0, r = x;
        //找满足 mid*mid<=x的最大mid
        while (l < r) {
            long long mid = (l + r + 1) >> 1;
            if (mid * mid <= x) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
```

## [367. 有效的完全平方数-二分](https://leetcode.cn/problems/valid-perfect-square/)

给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

### 思路

找满足条件（mid*mid>=num）的最小的数，满足`mid*mid==num?`即可。

如果要使用sqrt

可以直接进行判断`sqrt(num)*sqrt(num)==num`

### 代码

```cpp
    bool isPerfectSquare(int num) {
        long long l = 1, r = num;
        while (l < r) {
            long long mid = (l + r) >> 1;
            if (mid * mid >= num) r = mid;
            else l = mid + 1;
        }
        if (l*l==num) return true;
        return false;
    }
```

