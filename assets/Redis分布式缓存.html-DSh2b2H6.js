import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as a,d as t}from"./app-9oaKq5Mv.js";const s={},n=t(`<h1 id="redis分布式缓存" tabindex="-1"><a class="header-anchor" href="#redis分布式缓存"><span>Redis分布式缓存</span></a></h1><h2 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化"><span>Redis持久化</span></a></h2><p>Redis持久化有两种方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h3 id="rdb持久化" tabindex="-1"><a class="header-anchor" href="#rdb持久化"><span>RDB持久化</span></a></h3><p>RDB（Relational<br> Database）持久化是指将内存中的数据库状态保存到硬盘上的一种持久化存储方式，以便在服务器重新启动时恢复数据。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h4 id="执行时机" tabindex="-1"><a class="header-anchor" href="#执行时机"><span>执行时机</span></a></h4><ol><li><strong>手动触发：</strong> 可以使用命令 <code>SAVE</code> 或 <code>BGSAVE</code> 来手动触发RDB持久化。 <ul><li><code>SAVE</code> 阻塞服务器进程，直到持久化过程完成，期间服务器不能处理其他请求。</li><li><code>BGSAVE</code> 在后台进行持久化，不会阻塞服务器的正常操作。</li></ul></li><li><strong>自动触发：</strong></li></ol><ul><li>你可以通过配置文件中的 <code>save</code><br> 指令设置自动触发RDB持久化的条件。默认配置中会有一条规则，表示当900秒（15分钟）内至少有1个键被修改，就执行 <code>BGSAVE</code> 操作。</li><li>Redis停机时</li></ul><p>执行save命令</p><p>查看保存在哪里：<code>config get dir</code>,即redis的安装目录<br><img src="https://s2.loli.net/2023/11/10/aZDStMg5HluspE2.webp" alt="image.png"></p><p>执行bgsave<br><img src="https://s2.loli.net/2023/11/10/uc8diKNf52IPVsR.webp" alt="image.png"><br> 这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p>修改redis.conf文件：<br><img src="https://s2.loli.net/2023/11/10/Tra9dOvcDlMnqLR.webp" alt="image.png"></p><p>修改save之后的保存位置：<br><img src="https://s2.loli.net/2023/11/10/kXnWuKJriOtz3be.webp" alt="image.png"></p><h4 id="rdb原理" tabindex="-1"><a class="header-anchor" href="#rdb原理"><span>RDB原理</span></a></h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。<br> fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><h3 id="aof持久化" tabindex="-1"><a class="header-anchor" href="#aof持久化"><span>AOF持久化</span></a></h3><p>AOF（Append-only File）是Redis中另一种持久化机制，用于将写操作追加到一个文件中。相较于RDB持久化，AOF持久化提供了更细粒度的持久化，记录每个写命令的操作，而不是周期性地保存整个数据集的快照。<br> 等 需要数据的时候，将这个文件 从头到尾执行一边，即可 得到准确的数据</p><p>修改conf文件 进行 配置：</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><pre class="language-conf"><code># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改记录 频率：</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><pre class="language-conf"><code># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://s2.loli.net/2023/11/10/Tyzh4xVulXjHrJm.webp" alt="image-20210725151654046.png"></p><h4 id="aof文件重写" tabindex="-1"><a class="header-anchor" href="#aof文件重写"><span>AOF文件重写</span></a></h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>bgrewriteaof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以配置自动触发：</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><pre class="language-conf"><code># AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种方式对比：<br><img src="https://s2.loli.net/2023/11/10/2DcJhLBUq7HlzSE.webp" alt="image-20210725151940515.png"></p><h2 id="redis主从集群" tabindex="-1"><a class="header-anchor" href="#redis主从集群"><span>Redis主从集群</span></a></h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。<br><img src="https://s2.loli.net/2023/11/10/MTGOrgI9ewxtKA3.webp" alt="image-20210725152037611.png"></p><p>搭建Redis集群<br> 新建三个文件夹 7001 7002 7003<br> 将配置文件拷贝到每一个文件夹下面<br> 分别修改每个配置文件的端口为7001 ,7002,7003<br> 修改rdb文件的保存目录：</p><div class="language-conf line-numbers-mode" data-ext="conf" data-title="conf"><pre class="language-conf"><code>dir /Users/houyunfei/tools/redis/7001
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>三个都需要修改</p><p>然后启动三个redis</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>redis-server <span class="token number">7001</span>/redis.conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://s2.loli.net/2023/11/10/yKohGxP4QReSBXr.webp" alt="image.png"></p><p>让7002的主设置为7001，7003同理<br><img src="https://s2.loli.net/2023/11/10/mDjUNG4VBvPLHAe.webp" alt="image.png"></p><p>可以看到此时7001成为了master<br><img src="https://s2.loli.net/2023/11/10/yw9ZWephJfF2Brn.webp" alt="image.png"></p><p>当7001成为了主之后，他设置的值都可以被7002和7003读取到，但是7002和7003不可以写，只可以读<br><img src="https://s2.loli.net/2023/11/10/dRXnDLQ3eYUcOpb.webp" alt="image.png"></p><p>主从分离：</p><ul><li>主节点做写</li><li>从节点做读</li></ul>`,43),l=[n];function r(d,p){return i(),a("div",null,l)}const h=e(s,[["render",r],["__file","Redis分布式缓存.html.vue"]]),m=JSON.parse('{"path":"/java/5-%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html","title":"分布式缓存","lang":"en-US","frontmatter":{"title":"分布式缓存","date":"2023-11-10T00:00:00.000Z","category":["中间件","Redis"],"tag":["中间件","Redis"],"description":"Redis分布式缓存 Redis持久化 Redis持久化有两种方案： RDB持久化 AOF持久化 RDB持久化 RDB（Relational Database）持久化是指将内存中的数据库状态保存到硬盘上的一种持久化存储方式，以便在服务器重新启动时恢复数据。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前...","head":[["meta",{"property":"og:url","content":"https://github.com/zhangruyi3906/blog/java/5-%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"}],["meta",{"property":"og:site_name","content":"乘风破浪（长风破浪会有时，直挂云帆济沧海）"}],["meta",{"property":"og:title","content":"分布式缓存"}],["meta",{"property":"og:description","content":"Redis分布式缓存 Redis持久化 Redis持久化有两种方案： RDB持久化 AOF持久化 RDB持久化 RDB（Relational Database）持久化是指将内存中的数据库状态保存到硬盘上的一种持久化存储方式，以便在服务器重新启动时恢复数据。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s2.loli.net/2023/11/10/aZDStMg5HluspE2.webp"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-14T07:14:40.000Z"}],["meta",{"property":"article:author","content":"dreamchaser"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2023-11-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-14T07:14:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式缓存\\",\\"image\\":[\\"https://s2.loli.net/2023/11/10/aZDStMg5HluspE2.webp\\",\\"https://s2.loli.net/2023/11/10/uc8diKNf52IPVsR.webp\\",\\"https://s2.loli.net/2023/11/10/Tra9dOvcDlMnqLR.webp\\",\\"https://s2.loli.net/2023/11/10/kXnWuKJriOtz3be.webp\\",\\"https://s2.loli.net/2023/11/10/Tyzh4xVulXjHrJm.webp\\",\\"https://s2.loli.net/2023/11/10/2DcJhLBUq7HlzSE.webp\\",\\"https://s2.loli.net/2023/11/10/MTGOrgI9ewxtKA3.webp\\",\\"https://s2.loli.net/2023/11/10/yKohGxP4QReSBXr.webp\\",\\"https://s2.loli.net/2023/11/10/mDjUNG4VBvPLHAe.webp\\",\\"https://s2.loli.net/2023/11/10/yw9ZWephJfF2Brn.webp\\",\\"https://s2.loli.net/2023/11/10/dRXnDLQ3eYUcOpb.webp\\"],\\"datePublished\\":\\"2023-11-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-14T07:14:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"dreamchaser\\",\\"url\\":\\"https://github.com/zhangruyi3906\\"}]}"]]},"headers":[{"level":2,"title":"Redis持久化","slug":"redis持久化","link":"#redis持久化","children":[{"level":3,"title":"RDB持久化","slug":"rdb持久化","link":"#rdb持久化","children":[]},{"level":3,"title":"AOF持久化","slug":"aof持久化","link":"#aof持久化","children":[]}]},{"level":2,"title":"Redis主从集群","slug":"redis主从集群","link":"#redis主从集群","children":[]}],"git":{"createdTime":1718196522000,"updatedTime":1718349280000,"contributors":[{"name":"zhangruyi3906","email":"3023208132@qq.com","commits":3}]},"readingTime":{"minutes":3.63,"words":1089},"filePathRelative":"java/5-中间件/Redis分布式缓存.md","localizedDate":"November 10, 2023","excerpt":"\\n<h2>Redis持久化</h2>\\n<p>Redis持久化有两种方案：</p>\\n<ul>\\n<li>RDB持久化</li>\\n<li>AOF持久化</li>\\n</ul>\\n<h3>RDB持久化</h3>\\n<p>RDB（Relational<br>\\nDatabase）持久化是指将内存中的数据库状态保存到硬盘上的一种持久化存储方式，以便在服务器重新启动时恢复数据。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>","autoDesc":true}');export{h as comp,m as data};
