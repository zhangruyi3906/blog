---
title: 算法刷题-字符串
date: 2023-10-26
category:
  - Algorithm
  - 字符串
tag:
  - Algorithm
  - 字符串
---

# 算法刷题-字符串

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

### 思路

遍历字符串长度的一半，然后swap第`i`和第`n-i+1`个字符即可

### 代码

```cpp
    void reverseString(vector<char>& s) {
        int n=s.size();
        for(int i=0;i<n/2;i++) swap(s[i],s[n-i-1]);
    }
```

## [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

### 思路

遍历字符串，每次判断`2*k`个字符，

+ 如果长度小于`k`,那就直接截取全部，然后`reverse`
+ 否则先截取前`k`个，然后`reverse`，再截取剩余的，拼接上

### 代码

```cpp
string reverseStr(string s, int k) {
        int n=s.size();
        string res="";
        for(int i=0;i<n;i+=2*k){
            string tmp;
            if(n-i+1<k){
                tmp=s.substr(i);
                reverse(tmp.begin(),tmp.end());
            }else {
                tmp=s.substr(i,k);
                reverse(tmp.begin(),tmp.end());
                if(i+k<n)
                	tmp+=s.substr(i+k,k);
            }
            res+=tmp;
        }
        return res;
    }
```

## [LCR 122. 路径加密](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

假定一段路径记作字符串 `path`，其中以 "`.`" 作为分隔符。现需将路径加密，加密方法为将 `path` 中的分隔符替换为空格 "` `"，请返回加密后的字符串。

### 思路

遍历字符串直接替换即可

### 代码

```cpp
    string pathEncryption(string path) {
        for(char &c:path) {
            if(c=='.') c=' ';
        }
        return path;
    }
```

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

### 思路

先双指针，找到从头开始不是空格的位置，找到从最后开始不是空格的位置

然后遍历整个字符串，双指针找到不是空格的位置，中间这一段就是字符串，放到`vector`数组中，最后reverse一下即可

### 代码

```cpp
string reverseWords(string s) {
        int l = 0, r = s.size() - 1;
        while (l<=r &&s[l] == ' ')l++;
        while (l<=r &&s[r] == ' ')r--;
        vector<string> res;
        for (int i = l; i <= r; i++) {
            int j = i;
            string tmp;
            while (j<=r &&s[j] != ' ')tmp += s[j], j++;
            res.push_back(tmp);
            while (j<=r &&s[j] == ' ') j++;
            i = j - 1;
        }
        std::reverse(res.begin(), res.end());
        string t;

        for (int i = 0; i < res.size(); i++) {
            t += res[i];
            if (i != res.size() - 1) t += " ";
        }
        return t;
    }
```

## [LCR 182. 动态口令](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

某公司门禁密码使用动态口令技术。初始密码为字符串 `password`，密码更新均遵循以下步骤：

- 设定一个正整数目标值 `target`
- 将 `password` 前 `target` 个字符按原顺序移动至字符串末尾

请返回更新后的密码字符串。

### 思路

直接用库函数截取字符串即可

### 代码

```cpp
    string dynamicPassword(string password, int target) {
        string res= password.substr(target)+password.substr(0,target);
        return res;

    }
```

## [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

### 思路

数据范围比较小，可以直接$O(n^2)$算法，用截取字符串的库函数实现

也可以使用效率高的kmp算法

或者字符串哈希算法

### 代码

```cpp
    int strStr(string haystack, string needle) {
        int n=haystack.size(),m=needle.size();
        for(int i=0;i+m-1<n;i++){
            if(haystack.substr(i,m)==needle) return i;
        }
        return -1;
    }
```

## [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

### 思路

可以由字串重复构成，那么字串的长度一定是s的因子，可以先筛去一部分没用的数，

剩下的因子很少，可以直接$O(n^2)$暴力判断

### 代码

```cpp
    bool check(string s,string t){
        for(int i=0;i<s.size();i+=t.size()){
            if(s.substr(i,t.size())!=t) return false;
        }
        return true;
    }

    bool repeatedSubstringPattern(string s) {
        int n=s.size();
        for(int i=1;i<n;i++){
            if(n%i!=0) continue;
            string tmp=s.substr(0,i);
            if(check(s,tmp)) return true;
        }
        return false;
    }
```
