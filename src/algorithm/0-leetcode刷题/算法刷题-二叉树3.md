---
title: 算法刷题-二叉树3
date: 2023-11-01
category:
  - Algorithm
  - 二叉树
tag:
  - Algorithm
  - 二叉树
---
# 算法刷题-二叉树 3

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

### 思路

把当前层的节点都弹出放入列表中，然后遍历列表，使得每个元素的next指向下一个
注意最后一个要指向空：`None`

### 代码

```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return root
        queue = collections.deque([root])
        while queue:
            sz = len(queue)
            ls = []
            for _ in range(sz):
                node = queue.popleft()
                ls.append(node)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            for i in range(len(ls) - 1):
                ls[i].next = ls[i + 1]
            ls[len(ls) - 1].next = None
        return root
```


## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

给定一个二叉树：

```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。


### 思路

根上一题的做法一模一样，代码不用变
### 代码

```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        q = collections.deque([root])
        while q:
            sz = len(q)
            ls = []
            for _ in range(sz):
                node = q.popleft()
                ls.append(node)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                for i in range(len(ls)-1):
                    ls[i].next = ls[i+1]
                ls[len(ls) - 1].next = None
        return root
```

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。****


### 思路

递归：
如果左子树不为空，那么就进入左子树，如果右子树不为空，那么就进入右子树
当前点的深度 为 左/右 递归得到的结果+1
### 代码

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1
```


## [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。


### 思路

广度优先搜索，当那一层没有左子树 并且没有右子树的时候，直接返回答案，此时就是最小的深度
### 代码

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        queue = collections.deque([(root, 1)])
        while queue:
            node, depth = queue.popleft()
            if not node.left and not node.right:
                return depth
            if node.left:
                queue.append((node.left, depth + 1))
            if node.right:
                queue.append((node.right, depth + 1))
        return 0
```
